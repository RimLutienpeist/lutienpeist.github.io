# 计算机的早期发展——从集成电路到操作系统，从文件系统到屏幕

!!!note "章节对应"
	本部分对应该课堂的第17~集。

## 集成电路和摩尔定律

之前硬件只讲到到了晶体管，我们接下来继续讲硬件。

### 分立元件

分立元件是指只有一个电路元件的组件。可以是被动的（例如，电阻、电容、电感），也可以是主动的（例如，晶体管、真空管）。

电子计算机就是建立于无数分立元件之上。为了提高性能，需要的分立元件数量多达几十万，而这些分立元件由于是独立的，又需要通过接电线或焊接的方式进行十分复杂的连接，这导致电路变得相当复杂，这一问题叫 数字暴政（tyranny of numbers）。这一问题的严重性在上世纪六十年代达到了顶点。

### 集成电路

数字暴政的一种解决方法，简单来说，就是与其把多个独立部件用电线连起来，拼装出计算机，我们可以把多个组件包在以成一个新的独立组件，叫做 **集成电路（integrated circuit/IC）**。IC就像电脑工程师的乐高积木，可以组合出无数种设计。为了方便将IC拼装在一起，工程师发明了 **印刷电路板（printed circuit board/PCB）**。PCB可大规模生产，无需焊接或用一大堆线，它通过蚀刻金属线的方式把零件连接到一起，而且更加可靠。芯片的核心就是一块IC。

![image-20240124110140778](https://raw.githubusercontent.com/RimLutienpeist/image-hosting/main/image-20240124110140778.png)

不过单纯将分立元件塞进IC的话，体积还是不小，于是全新的制作工艺 **光刻** 登场了。光刻简单来说就是用光把复杂图案印到材料上，比如半导体。这让IC的密度前所未有的高，体积变得十分小。

!!!note "光刻"
	这里比较简单就跳过了，笔记之后补。[17. 集成电路&摩尔定律-Integrated Circuits & Moore's Law_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1EW411u7th?p=17&vd_source=0a162b815969683030296b1fac5801b7)

### 摩尔定律

有了光刻之后，事情变得不一样了。60年代初，IC很少超过5个晶体管，因为塞不下；60年代中期，市场上出现了超过100个晶体管的IC。

于是戈登·摩尔提出了 **摩尔定律（Moore‘ Law）**：每两年左右，IC密度翻倍。

> 这人之后用  *Integrated* 和 *Electronics* （集合和电子）两个词给公司命名为 Intel ，目前最大的芯片制造商。之前提到的的 Intel4004 CPU 就是世界上第一个IC做的CPU。
>
> 值得一提的是，不只是IC，大多数电子器件都在以指数级的速度发展。
>
> 以及，摩尔定律**可能**要到接近极限了。目前晶体管已经是原子级别的大小的，光的波长不够短了，电子的量子隧穿效应也会引发漏电。

## 操作系统（OS）

### OS的诞生

> 在上世纪年代，计算机的运行速度得到了迅速发展。当输入程序的时间比程序运行时间还要长的时候，**操作系统（operating system/OS）**就应运而生了。 

操作系统也是一种程序，但是它有操作硬件的特殊权限，可以运行和管理其它程序。普通计算机开机第一个启动的程序就是操作系统，其它程序都由操作系统启动。

上世纪年代诞生了第一个OS，那还是给卡纸打孔的年代。这个OS作用是运行完一个程序后自动读取下一个程序的卡纸，这个过程叫 **批处理（batch processing）**。

之后的数十年，随着计算机的普及，人们开始分享程序，但是不同的计算机适配情况不同，例如CPU有差异，打印机有差异，外部设备（peripheral）有差异，等等。这种对底层有要求的交互非常恶心，需要程序员了解设备的硬件细节，同时程序员还很难拿到所有型号的设备来测试代码，更恶心了，这意味着你只能祈祷你的程序能够适配。

于是，更强大的OS作为软件与硬件之间的媒介出现了。具体来说，OS提供 **设备驱动程序（device driver）** 这种API来抽象硬件。程序员可以使用OS的标准化机制和 **输入输出硬件（Input&Output hardware，简称 I/O ）** 交互。

### 早期OS的功能

紧接着上面说的。人们发现了新的问题—— I/O （例如打印机）运行的时间比CPU慢得多，导致昂贵的CPU长时间空闲，于是开发了全新的OS，其可以在一个程序正在打印时，让下一个程序同一时间使用CPU，直到上一个程序打印完成，CPU再回到上一个程序继续剩下的计算。OS的这种能力被叫做 **多任务处理（multitasking）**。

当然这种模式下，为防止内存混乱，OS会给每个程序分配专属内存。而且各个程序的内存相互隔绝的、不会相互影响的，这叫 **内存保护（memory protection）**。但是专属内存的物理地址是不连续的，比较难追踪。为了隐藏复杂度，OS会把内存地址“虚拟化”，得到 **虚拟内存（virtual memory）**。简单来说，就是建立一个映射，将不连续的物理位置被映射为连续的、排列好的虚拟地址。

> 内存保护较差的OS在程序崩溃时可能会一并导致OS崩溃，造成蓝屏。

之后还有能够多用户操作的 **分时操作系统（time-sharing OS）**。多个用户可通过终端同时使用同一台计算机，分时操作系统会将计算机的资源（CPU、内存等等）分为多份，每份分配给一个用户，且不会相互影响。不过这种类型的OS其本身需要的内存相当大。

### 内核与外核

紧接着上面说的。某位C语言之父嫌当时的OS功能太多太杂了，不好用，就和别人写了个Unix。他们设计时将OC一分为二——内核与外部。

- **内核（kernel）** 是指OS的核心功能，如内存管理，多任务处理，以及 I/O 处理Unix。内核相当紧凑，意味着其功能很少。
- 外部是相对于内核而言，就是指程序和运行库一类的工具。

将内核理解为OS的身体，那么外部工具相当于OS手上拿的工具，但是注意这些工具也认为是属于OS的一部分。

??? "kernel panic"
	内核崩溃被称为 **内核致命错误（kernel panic）**，因为内核崩溃之后无法恢复，就会调用一个叫`panic`的函数。

Unix因其简单性被广泛使用。

## 内存&储存介质

!!!note "⛵引入"
	我们之前提过内存（memory）。内存一般是非永久性（non-permanent）的，一旦断电会导致内存里面的所有数据丢失，所以内存也叫 易失性存储器（volatile memory）。<br>当然还有一个不同于内存的东西——**存储器（storage）**。存储器一般是永久性的，如你的硬盘、U盘。<br>无论是内存还是存储器都属于存储介质（英文也是storage），接下来让我们展开讲讲。

### 打孔卡纸

最早的存储介质是之前提过的打孔卡纸。卡纸便宜耐用，但是打了孔之后卡纸无法恢复原样，所以只能写入一次（write-once）。如此，卡纸不适合储存临时值。

于是40年代时有人发明了 **延迟线存储器（delay line memory）**。

###  延迟线存储器

![image-20240125114609690](https://raw.githubusercontent.com/RimLutienpeist/image-hosting/main/image-20240125114609690.png)

![image-20240125114655906](https://raw.githubusercontent.com/RimLutienpeist/image-hosting/main/image-20240125114655906.png)

如此循环。其也被叫做 **顺序存储器（sequence memory）**，或 **循环存储器（cycle-access memory）**。显然这玩意儿的缺点是，如果我们想读取某一位的数据，我们需要等带循环。

但是我们想要一个 **随机存取存储器（random access memory）**，其可以随时访问任何位置。于是出现了 磁芯存储器。

### 磁芯存储器

这种存储器在50年代就被应用了，并流行了20多年，原理利用了环形磁性的磁化方向会一直保持的特性，即便没有电流。两种磁化方向分别可以表示0和1。

![image-20240125115228479](https://raw.githubusercontent.com/RimLutienpeist/image-hosting/main/image-20240125115228479.png)

这东西安全性很高，今天依旧有企业在生成。但是这东西很贵，70年代的时候即便工艺改善了1bit也要1美分。于是有人发明了磁带。

### 磁带

磁带（tape） 是一种纤薄柔软的长条磁性带子，卷在轴上。磁带通过 磁带驱动器（tape drive） 进行各种操作。驱动器里面有 写头（write head） ，其通过电流产生磁场，使得磁带一小部分被磁化，相应的，电流的方向控制了极性，以表示0和1。 读头（read head） 可以非破坏性地检测极性。

驱动器很贵，但磁带很便宜，这玩意儿今天也在用于数据存档。但是这东西是顺序存储器。然后磁盘来了。

### 磁盘

磁盘（hard disk）原理类似磁带，就是表面有磁性，由读头、写头进行操作。但是磁盘可以一张一张叠起来，这意味着可以叠一堆磁盘作为一个整体的存储器，而且读写头可以自由地放到磁盘表面任何一个地方，这意味着可以直接找到需要的bit，不用等待，不过寻找需要读写头移动，这还是需要时间的，这种时间被叫做 寻道时间（seek time）。

### 硬盘与软盘

硬盘（hard disk）和软盘（floppy disk）都是属于磁盘。这些是机械硬盘。

### 固态硬盘

固态硬盘（solid state drive/SSD），没有移动部件，故访问速度更快，但慢于RAM。

### 光盘

例如CD，DVD，原理是表面的小孔造成光的不同反射。

## 文件系统

### 文件格式

文件格式代表着文件数据排列的方式。所有文件都是用二进制储存的，即所有文件在底层长得都一个样——一长串的二进制。这就是为什么文件格式是如此重要。

txt文本文件的二进制数通过对应的编码来解读。

还有波形文件Wave，即wav文件，储存音频数据，解读这东西我们需要直到码率（bit rate）这类数据，这种关于数据的数据被叫做 **元数据（meta data）**。元数据储存在文件开头，所以也被叫做 **文件头（header）**。

还有个叫位图（bitmap）的文件，即bmp文件，储存图片的。 其以三原色为基础，按像素的顺序储存每个像素的三原色深度。

### 文件存储

然后是 目录文件/根目录（directory file），文件系统（file system），分平面（flat）和 分层，碎片整理。

## 压缩

压缩（compression）就是把数据占用的空间压得更小，即用更少的bit存储数据。

### 无损压缩

无损压缩有两种常见方法。

#### 减少重复数据/消除冗余

比如用 **游程编码（run-length encoding）**——每部分数据前面放一个bit表示这部分的数据重复几次。显然这样压缩之后我们还可以还原出压缩前的二进制数据，这叫 **无损压缩（lossless）**，即解压缩后数据和压缩前的一模一样。

#### 用更紧凑的表示方法

一种方法是 **DFTBA（字典编码）** ，其用一个字典存储 code 与 data 之间的对应关系。具体来说，就是将数据分为多个部分，生成对应的 **紧凑代码（compact code）**。就是**哈夫曼编码**啦。然后目录里放映射关系，用短的编码替换数据。

上面两种方法经常组合使用，几乎所有**无损压缩**格式都用了它们，如gif，png，pdf。zip。

### 有损压缩

不过呢，有些数据即便丢掉一些数据，人类也看不出区别，例如音频中超出人类听力范围的部分。于是有损（lossy）压缩技术来了，这种技术很复杂。例如你电话里听到的音频。还有wav和flac都是未压缩的，mp3属于有损压缩的。

删掉人类无法感知的数据的方法，叫做 感知编码（perceptual code），其依赖于人类的感知模型，模型来自心理物理学领域。这是各种有损压缩图像格式的基础，例如jpeg/jpg——我们善于看到尖锐对比，例如物体边缘，却看不出颜色的细微变化，于是jpg将图像分解成一堆8x8的像素块，将这些像素块中可以模糊的给模糊掉。由此，jpg大小一般能减少到十分之一。

视频的一种压缩方法为 **时间冗余（temporal redundancy）**。不用每一帧都存画面中的全部像素，而是只存有变化的。这被用于存储画面变化较少的情况。更高级的方法有识别视频中的各个部分，发现帧与帧之间有相似的部分，就直接复用相似的部分，当然会做适当的调整，如拉伸/选择，变暗/变亮，等待。例如，一只手从画面左边移动到右边，那么手的图像可能从头到尾都用的是第一帧的手。MPGE-4标准就利用了这种方法，大小可减少到原来的二十分之一到二百分之一。

当然，这种方式可能会出错，就会出现下面的情况

![image-20240125163324197](https://raw.githubusercontent.com/RimLutienpeist/image-hosting/main/image-20240125163324197.png)

![image-20240125163341563](https://raw.githubusercontent.com/RimLutienpeist/image-hosting/main/image-20240125163341563.png)

## 命令行界面

!!!note "引入"
	之前讲过很多计算机组件之间的——比如RAM与CPU之间——也讲过很多人机交互，交互界面我们讲过接线板、控制面板等待。早期计算机科学是尽可能迁就计算机而非人类，于是人类很难使用计算机，而且一旦输入之后就没有进一步的交互，只能等待结果输出。

目前常见的键盘布局为 **QWERTY**。电传打字机的电传交互界面被应用到了计算机——就是人通过打字机输入命令，然后按回车，计算机会通过打字机输出结果。计算机的这种交互界面被叫做 **命令行界面（command line interface）** ，在60~80年代为主要人机交互方式。70年代的时候屏幕足够便宜，开始替代电传打字机，但继承了电传打字机协议。

> 常见的命令行指令有 `ls`("list"), `cd`(change directory)。

编程大部分工作依旧是打字，用命令行比较自然，所以命令行依旧常见。

下图左为计算机，种为电传打字机，右为屏幕。三者是相互独立的。

![image-20240125165459550](https://raw.githubusercontent.com/RimLutienpeist/image-hosting/main/image-20240125165459550.png)

## 屏幕&2D图形显示

早期计算机的文本任务与图像任务是分开的，因为当时的屏幕无法清晰显示文字，还是用打字机好使。屏幕更多用于debug。

早期屏幕为“电子+荧光屏”，分矢量扫描和光栅扫描，不用像素是因为其需要大量内存。后面有了像素（pixel）。

光栅扫描的计算机需要额外的硬件来读取内存里的图像数据，将其转化为光栅图像，然后才能显示在屏幕上，因早期的图像只有字符，所以这硬件叫做 字符生成器，算是第一代 **显卡（graphics card）**。这时候屏幕还只能显示字符。一开始是内存里面专门用于存放像素数据的区域叫 帧缓冲区（frame buffer），后来把这区域单独放入显卡，叫做 **高速视频内存（video-RAM/VRAM）**。

此外，也有直接用矢量“画图”的方式，就是通过命令来画线段，操作起来就像化身校长进行微操（CSS点赞）。由此发展出了交互式图形界面，用途是 **计算机辅助设计（computer-aided design/CAD）**。这个时候是还年代，还是纸带时代。

位图显示（bitmapped display），是指用内存的bit显示像素，两者之间为一一对应关系。